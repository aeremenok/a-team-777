import org.apache.bcel.Constants;
import org.apache.bcel.generic.ClassGen;

COMPILER CompilationUnit

// Функция возвращает токен, следующий за текущим (заглядывает вперед)
boolean next(int i)
	{
		scanner.ResetPeek();
		Token x = scanner.Peek();
		return (x.kind == i);
	}
	
    String idValue()
    {
        return "todo";
    }
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  dot = '.'.
  stringCh  = ANY - '"' - cr - lf. 
/* спец символы
   stringCh  = ANY - '"' - '\\' - cr - lf.
   printable =  '\u0020' .. '\u007e'.
   string  = '"' { stringCh | '\\' printable } '"'.
*/


TOKENS
	realNumber =             ['-']  [digit { digit }  dot]  digit { digit } ["e-" digit {digit}] .
	string = '"' {stringCh} '"'.
	interface =		"interface".
	openRoundBracket = '('.
	closeRoundBracket = ')'.
	openCurlyBracket = '{'.
	closeCurlyBracket = '}'.
	id = letter { letter | digit }.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO cr lf

IGNORE cr + lf + tab

PRODUCTIONS

/*----------------------------------identifier----------------------------------*/
identifier<out String id>
= 
(. id = idValue(); .)
id
.
/*----------------------------------CompilationUnit----------------------------------*/
CompilationUnit = 
	typeDeclaration {typeDeclaration}
.
/*----------------------------------typeDeclaration----------------------------------*/
typeDeclaration =
	[accessSpecifier]
	(interfaceDeclaration | classDeclaration)
.
/*----------------------------------classDeclaration----------------------------------*/
classDeclaration =  
    (. int modifier = Constants.ACC_PUBLIC; .)
    (. int fMod = 0; .)
    (. int sMod = 0; .)
	[finalAccess<out fMod>]    (.modifier |= fMod;.)
	[staticAccess<out sMod>]   (.modifier |= sMod;.)
	"class"                    (.ClassGen classGen;.)
	identifier<out className>
	["extends" identifier<out superName>]
	["implements" 
	identifier<out interfaceName>
	 {',' 
	 identifier<out interfaceName>
	 }]
	classBody
.
/*----------------------------------staticAccess----------------------------------*/
staticAccess<out int modifier> 
= 
 "static" (.modifier = Constants.ACC_STATIC;.)
.
/*----------------------------------finalAccess----------------------------------*/
finalAccess<out int modifier>
=
 "final" (.modifier = Constants.ACC_FINAL;.)
.
/*----------------------------------interfaceDeclaration----------------------------------*/
interfaceDeclaration =  //todo
	"interface"
	identifier<out interfaceName>
   ["extends" 
   identifier<out superInterfaceName>
   ]
	interfaceBody
.
/*----------------------------------accessSpecifier----------------------------------*/
accessSpecifier =
	("public" | "protected" | "private" )
.
/*----------------------------------type----------------------------------*/
type =
	("byte" | "short" | "int" | "long" | "char"| "float" | "double" | "bool" | "void")
.
/*----------------------------------formalParameterList----------------------------------*/
formalParameterList =  //todo
	(type | 
	identifier<out varName>
	) identifier<out varName>
	{',' (type | identifier<out varName>) identifier<out varName>}
.
/*----------------------------------classBody----------------------------------*/
classBody =
	'{'
	{
		[accessSpecifier]
		((IF(next(_openRoundBracket))
			identifier<out someThing> //todo
			openRoundBracket [formalParameterList] closeRoundBracket 
				openCurlyBracket {statement} closeCurlyBracket
		)
		|
		(
		[finalAccess<out fMod>]
		[staticAccess<out sMod>]
		(IF(next(_identifier))
			(type | 
			identifier<out someThing> //todo
			)
			identifier<out someThing> //todo
			(
				(
					openRoundBracket [formalParameterList] closeRoundBracket 
						openCurlyBracket {statement} closeCurlyBracket
				)
			|
				(
					['=' expression] ';'
				)
			)
		)
		)
		)
	}
	'}'
.
/*----------------------------------statement----------------------------------*/
statement =	
	(
		("if" openRoundBracket expression closeRoundBracket 
			((openCurlyBracket {statement} closeCurlyBracket) | statement)
			["else" ((openCurlyBracket {statement} closeCurlyBracket) | statement)]
		)
		|("while" openRoundBracket expression closeRoundBracket 
			((openCurlyBracket {statement} closeCurlyBracket) | statement))
		|("return" [expression] ';')
		|("new" expressionName openRoundBracket [expression] closeRoundBracket)
		|(openCurlyBracket {statement} closeCurlyBracket)
		|(type 
		identifier<out someThing> //todo
		 ['=' expression]
			{',' 
			identifier<out someThing> //todo
			 ['=' expression]} ';')
		|(
		identifier<out someThing> //todo
		 ['('[expression {',' expression}]')'] 
		   {'.' 
		   identifier<out someThing> //todo
		    ['('[expression {',' expression}]')']}
			((
			identifier<out someThing> //todo
			 ['=' expression] {',' 
			identifier<out someThing> //todo
			 ['=' expression]} ';')
			|/*(openRoundBracket [expression {',' expression}] closeRoundBracket */';'/*)*/
			|(assignmentOperator expression ';')
			))
		|("super" {'.' 
		identifier<out someThing> //todo
		} 
			openRoundBracket [expression {',' expression}] closeRoundBracket ';')
	)
.

/*----------------------------------interfaceBody----------------------------------*/
interfaceBody =
	'{'
	{
		[accessSpecifier]
		[finalAccess<out fMod>]
		[staticAccess<out sMod>]
		(type | 
		identifier<out someThing> //todo
		)
		identifier<out someThing> //todo	
		openRoundBracket [formalParameterList] closeRoundBracket ';'
	}
	'}'
.
/*----------------------------------expression----------------------------------*/
expression =
	conditionalOrExpression 
.
/*----------------------------------conditionalOrExpression----------------------------------*/
conditionalOrExpression =
	conditionalAndExpression {"||" conditionalOrExpression}
.
/*----------------------------------conditionalAndExpression----------------------------------*/
conditionalAndExpression =
	inclusiveOrExpression {"&&" conditionalAndExpression}
.
/*----------------------------------inclusiveOrExpression----------------------------------*/
inclusiveOrExpression =
	exclusiveOrExpression {'|' inclusiveOrExpression}
.
/*----------------------------------exclusiveOrExpression----------------------------------*/
exclusiveOrExpression =
	andExpression {'^' exclusiveOrExpression}
.
/*----------------------------------andExpression----------------------------------*/
andExpression =
	equalityExpression {'&' andExpression}
.
/*----------------------------------equalityExpression----------------------------------*/
equalityExpression =
	relationalExpression {("==" | "!=") equalityExpression}
.
/*----------------------------------relationalExpression----------------------------------*/
relationalExpression =
	shiftExpression {("<" | ">" | "<=" | ">=") relationalExpression}
.
/*----------------------------------shiftExpression----------------------------------*/
shiftExpression =
	additiveExpression {("<<" | ">>" | "<<<" ) shiftExpression}
.
/*----------------------------------additiveExpression----------------------------------*/
additiveExpression =
	multiplicativeExpression {('+' | '-' ) additiveExpression}
.
/*----------------------------------multiplicativeExpression----------------------------------*/
multiplicativeExpression =
	unaryExpression {('*' | '/' | '%' ) multiplicativeExpression}
.
/*----------------------------------unaryExpression----------------------------------*/
unaryExpression =
	expressionName {('*' | '/' | '%' ) unaryExpression}
.
/*----------------------------------expressionName----------------------------------*/
expressionName =
	(((
	identifier<out someThing> //todo
	 | "super") ['('[expression {',' expression}]')'] 
	   {'.' 
	   identifier<out someThing> //todo
	   ['('[expression {',' expression}]')']}) | (realNumber)|(string))
.
/*----------------------------------assignmentOperator----------------------------------*/
assignmentOperator =
	("=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=")
.
END CompilationUnit.
