В папке Coco расположенно все связанное с генератором компиляторов CoCoR. Туда собственно не лезем.
В папке Gram есть файлики Parser.frame и Scanner.frame. В каждом из описанно как Coco будет генерить соответствующие фалы .h и .cpp. 
Их я собствнное и не правил.
Самый интересный файл Gram.atg, в котором описывается грамматика нашего языка. Для понимания чего там происходит, читайте комментарии
внутри файла atg.
Объясню проблему. Coco строит нисходящий анализатор только для LL(1) грамматики,
то есть допустим на каком-то шаге разбора могут встретиться конструкции типа: 
["public"|"private"|"protected"] ["class"|"interface"]
Если описать это двумя правилами вывода, типа
 Сlass =
	[("public"|"private"|"protected")] "class" ...
.
и 
 Interface =
	[("public"|"private"|"protected")] "interface" ...
.
и использовать эти два правила в третьем как 
 (Сlass | Interface)
To возникнет проблем. При разборе файла, при нахождении например public Синтаксический анализатор не сможет определить к какому из правил 
перейти, так как не умеет заглядывать на символ вперед. То есть грамматика должна быть описанна так, чтобы по каждому символу можно 
было бы однозначно определить правило.
Для данного примера можно легко это обойти просто вынести спецификатор за правило:
 Сlass =
	"class" ...
.
и 
 Interface =
	"interface" ...
.
... [("public"|"private"|"protected")](Сlass | Interface)

Но так сделать можно не всегда и можно немножко обмануть CoCo, написав функцию
bool next(int i)
    {
       scanner->ResetPeek();
       Token* x = scanner->Peek();
       return x->kind == i;
    };
Которая заглядыват за текущий токен и сравниват его с переданным в параметре i.
чтобы понять что такое i, расскажу немного что происходит с токенами.
Если глянуть в файл parser.h, встретится такой участок кода:
class Parser {
private:
	enum {
		_EOF=0,
		_identifier=1,
		_realNumber=2,
		_string=3,
		_interface=4,
		_final=5,
		_static=6,
		_openRoundBracket=7,
		_closeRoundBracket=8,
		_openCurlyBracket=9,
		_closeCurlyBracket=10, ...

где объявленным нами в секции описания токенов (в файле Gram.atg) присваиваются в соответствие числа и переменная из enuma.
Все остальные встречающиеся в правилах токены типо как я описал в примере токен "class" нумеруется им автоматически, но 
переменная из enuma не присваивается, поэтому узнать ее номер проблемотично. К чему собственно я, можете вы спросить? А вот
к чему, можно переписать наш пример так

в разделе токенов оперделить токен class = "class".
а в каком-то из правил 
IF(next(_class)) 
	("public"|"private"|"protected") "class"
Но тут тоже есть проблема, я намеренно убрал квадратные скобки, потому что в случае отсутствия спецификатора перед "class" 
анализатор выдаст ошибку, так как будет сравнивать с _class символ следующий следом за "class"


Запускается CocoR так:  \Coco.exe  Gram.atg.
У меня в проекте это строчка добавленна в custom building и вызывается автоматом, правда иногда изменения не подхватываются,
так что переодически приходится делать ReBuild. Файл для разбора жестко задан в программе и задается в через абсолютный путь.
Так что если чего либо создайте такой файл в такой дирректории, либо перекомпиляция.