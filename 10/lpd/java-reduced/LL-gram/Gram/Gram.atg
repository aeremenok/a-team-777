COMPILER CompilationUnit // собственно здесь описывает основное правило с которого начинается вывод

// Следуюящая функция будет примеком добавленна в сгенерированные .h и .cpp файлы
// Функция возвращает токен, следующий за текущим (заглядывает вперед)
bool next(int i)
    {
       scanner->ResetPeek();
       Token* x = scanner->Peek();
       return x->kind == i;
    };
  
/*--------------------------------------------------------------------------*/
// Секция в которой описываются символы  
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  dot = '.'.
  stringCh  = ANY - '"' - cr - lf. 
/* спец символы
   stringCh  = ANY - '"' - '\\' - cr - lf.
   printable =  '\u0020' .. '\u007e'.
   string  = '"' { stringCh | '\\' printable } '"'.
*/


// Секция описания токенов, каждое описание заканчивается точкой
TOKENS
	identifier  = letter { letter | digit }. // любое слово 
	realNumber =             ['-']  [digit { digit }  dot]  digit { digit } ["e-" digit {digit}] . // Действительное число
	string = '"' {stringCh} '"'. // Строка, ограниченная двойными кавычками
	interface =		"interface".
	final=			"final".
	static =		"static".
	openRoundBracket = '('.
	closeRoundBracket = ')'.
	openCurlyBracket = '{'.
	closeCurlyBracket = '}'.

// Секция в которой описывается комментарии
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO cr lf

IGNORE cr + lf + tab

// Секция правил вывода, каждое правило заканчивается точкой
PRODUCTIONS
/*----------------------------------CompilationUnit----------------------------------*/
CompilationUnit =
	typeDeclaration {typeDeclaration} // один и более описания типов
.
/*----------------------------------typeDeclaration----------------------------------*/
typeDeclaration =
	[accessSpecifier] // спецификаторы public, protected, private перед class или interface

	(interfaceDeclaration | classDeclaration) 
.
/*----------------------------------classDeclaration----------------------------------*/
classDeclaration =
	[final][static]
	"class"
	identifier // Имя класса
	["extends" identifier]
	["implements" identifier {',' identifier}]
	classBody
.
/*----------------------------------interfaceDeclaration----------------------------------*/
interfaceDeclaration =
	"interface"
	identifier // Имя интерфейса
   ["extends" identifier]
	interfaceBody
.
/*----------------------------------accessSpecifier----------------------------------*/
accessSpecifier =
	("public" | "protected" | "private" )
.
/*----------------------------------type----------------------------------*/
type =
	("byte" | "short" | "int" | "long" | "char"| "float" | "double" | "bool" | "void")
.
/*----------------------------------formalParameterList----------------------------------*/
formalParameterList =
	(type | identifier) identifier
	{',' (type | identifier) identifier}
	// Пример: int a, Foo1 b, bool c
.
/*----------------------------------classBody----------------------------------*/
classBody =
	'{'
	{ // любое количество
		[accessSpecifier]
		((IF(next(_openRoundBracket)) // Если вторым токеном идет открывающая круглая скобка,
						// то мы наткнулись на конструктор. Пример: Foo1()
			identifier  		// Имя класса
			openRoundBracket [formalParameterList] closeRoundBracket 
				openCurlyBracket {statement} closeCurlyBracket // Реализация конструктора
		)
		| // Если не конструктор, то переходим сюда, далее либо определение метода, либо члена
		(
		[final]
		[static]
		(IF(next(_identifier)) // Этот if  по идее не нужен, но я оставил на всякий случай
			(type | identifier) // Тип либо возращаемого значения функции, либо члена
			identifier // имя функции или переменной
			(
				(	// Формальные параметры функции
					openRoundBracket [formalParameterList] closeRoundBracket 
						// Реализация функции
						openCurlyBracket {statement} closeCurlyBracket
				)
			|
				(	// присвоение переменной значения
					['=' expression] ';'
				)
			)
		)
		)
		)
	}
	'}'
.
/*----------------------------------statement----------------------------------*/
statement =	
	(
		("if" openRoundBracket expression closeRoundBracket  // описание для if
			((openCurlyBracket {statement} closeCurlyBracket) | statement)
			["else" ((openCurlyBracket {statement} closeCurlyBracket) | statement)]
		)
		|("while" openRoundBracket expression closeRoundBracket // описание для while
			((openCurlyBracket {statement} closeCurlyBracket) | statement))
		|("return" [expression] ';') // описание для return
		|("new" expressionName openRoundBracket [expression] closeRoundBracket) // описание для new
		|(openCurlyBracket {statement} closeCurlyBracket)
		|(type identifier ['=' expression] // описание переменной, начинающейся со стандартного типа, перечисленных в type
			{',' identifier ['=' expression]} ';')
		|(identifier ['('[expression {',' expression}]')']  // начало для описания переменной сложно типа (в смысле  не type) либо присвоения значения переменной без объявления
		   {'.' identifier ['('[expression {',' expression}]')']} // здесь реализуется вызов плана Foo1(a,b).Foo2()
			((identifier ['=' expression] {',' identifier ['=' expression]} ';') // Собственно определение переменной
			|';' // Пустой оператор
			|(assignmentOperator expression ';') // присвоение переменной без объявления
			))
		|("super" {'.' identifier}  // описание для super
			openRoundBracket [expression {',' expression}] closeRoundBracket ';')
	)
.

/*----------------------------------interfaceBody----------------------------------*/
interfaceBody =
	'{'
	{
		[accessSpecifier]
		[final]
		[static]
		(type | identifier)
		identifier	
		openRoundBracket [formalParameterList] closeRoundBracket ';'
	}
	'}'
.
/*----------------------------------expression----------------------------------*/
expression = // Далее реализованно определение выражения через правую рекурсию, без скобок.
	conditionalOrExpression 
.
/*----------------------------------conditionalOrExpression----------------------------------*/
conditionalOrExpression =
	conditionalAndExpression {"||" conditionalOrExpression}
.
/*----------------------------------conditionalAndExpression----------------------------------*/
conditionalAndExpression =
	inclusiveOrExpression {"&&" conditionalAndExpression}
.
/*----------------------------------inclusiveOrExpression----------------------------------*/
inclusiveOrExpression =
	exclusiveOrExpression {'|' inclusiveOrExpression}
.
/*----------------------------------exclusiveOrExpression----------------------------------*/
exclusiveOrExpression =
	andExpression {'^' exclusiveOrExpression}
.
/*----------------------------------andExpression----------------------------------*/
andExpression =
	equalityExpression {'&' andExpression}
.
/*----------------------------------equalityExpression----------------------------------*/
equalityExpression =
	relationalExpression {("==" | "!=") equalityExpression}
.
/*----------------------------------relationalExpression----------------------------------*/
relationalExpression =
	shiftExpression {("<" | ">" | "<=" | ">=") relationalExpression}
.
/*----------------------------------shiftExpression----------------------------------*/
shiftExpression =
	additiveExpression {("<<" | ">>" | "<<<" ) shiftExpression}
.
/*----------------------------------additiveExpression----------------------------------*/
additiveExpression =
	multiplicativeExpression {('+' | '-' ) additiveExpression}
.
/*----------------------------------multiplicativeExpression----------------------------------*/
multiplicativeExpression =
	unaryExpression {('*' | '/' | '%' ) multiplicativeExpression}
.
/*----------------------------------unaryExpression----------------------------------*/
unaryExpression =
	expressionName {('*' | '/' | '%' ) unaryExpression}
.
/*----------------------------------expressionName----------------------------------*/
expressionName =
	(((identifier | "super") ['('[expression {',' expression}]')'] 
	   {'.' identifier['('[expression {',' expression}]')']}) | (realNumber)|(string))
.
/*----------------------------------assignmentOperator----------------------------------*/
assignmentOperator =
	("=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=")
.
END CompilationUnit.
