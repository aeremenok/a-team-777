/**
 * Реализация сортировки Шелла
 * 
 * @author lysenko
 */
public class ShellSort
    extends SortMethod
{

    /**
     * @param array - сортируемый массив
     */
    public ShellSort(
        Short[] array )
    {
        super( array );
    }

    /**
     * Выполнить сотрировку массива методом Шелла
     */
    protected void sort(Short[] arrayToSort)
        throws InterruptedException
    {

        /* При сортировке Шелла сначала сравниваются и сортируются между собой
         * ключи, отстоящие один от другого на некотором расстоянии d. После этого
         * процедура повторяется для некоторых меньших значений d, а завершается
         * сортировка Шелла упорядочиванием элементов при d = 1 (то есть, обычной
         * сортировкой вставками).
         *		
         *  Выбор длины промежутков (N - длина массива):
         *  1) d1 = N / 2, d2 = d1 / 2, ..., 1
         *  в худшем случае алгоритм выполнит c * N^2 операций
         *  2) все значения (3^j ? 1) / 2 < N;
         *  такая последовательность шагов приводит к алгоритму класса O(N^3 / 2)
         *  3) все значения (2^i)*(3^j) < N, в порядке убывания;
         *  в таком случае сложность алгоритма понижается до O(N(logN)^2)
         *  
         *  Выбираем вариант 3)
         */

        int[] d = { 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524 };

        int m = 0;

        while ( d[m] < _array.length )
        {
            ++m;
        }

        while ( --m >= 0 )
        {
            for ( int i = d[m]; i < _array.length; i++ )
            {
                int j = i;
                short h = _array[i];
                while ( (j >= d[m]) && (_array[j - d[m]] > h) )
                {
                    _array[j] = _array[j - d[m]];
                    j = j - d[m];
                }
                _array[j] = h;
            }
        }
    }

    /**
     * @return Имя метода
     */
    protected String getMethodName()
    {
        return "Shell sort";
    }

}
