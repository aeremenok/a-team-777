import org.apache.bcel.Constants;
import org.apache.bcel.generic.ClassGen;
import org.apache.bcel.generic.MethodGen;
import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.ObjectType;

import java.util.ArrayList;
import java.util.HashMap;

COMPILER CompilationUnit

// Функция возвращает токен, следующий за текущим (заглядывает вперед)
boolean next(int i)
	{
		scanner.ResetPeek();
		Token peek = scanner.Peek();
		return (peek.kind == i);
	}
	
	void checkTypes()
    {
        for ( String typeName : objectTypes.keySet() )
        {
            if (
                !typeName.equals("String") && 
                !typeName.equals("Vector") &&
                !classes.keySet().contains( typeName ) 
                )
            {
                SemErr( "type " + typeName + " not found" );
            }
        }
    }
    
    public class Args
    {
        Type[] argTypes = null;
        String[] argNames = null;
    }
	
    public HashMap<String, ClassGen> classes = new HashMap<String, ClassGen>();
    public HashMap<String, ObjectType> objectTypes = new HashMap<String, ObjectType>();
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  dot = '.'.
  stringCh  = ANY - '"' - cr - lf. 
/* спец символы
   stringCh  = ANY - '"' - '\\' - cr - lf.
   printable =  '\u0020' .. '\u007e'.
   string  = '"' { stringCh | '\\' printable } '"'.
*/


TOKENS
	realNumber =             ['-']  [digit { digit }  dot]  digit { digit } ["e-" digit {digit}] .
	string = '"' {stringCh} '"'.
	id = letter { letter | digit }.
	openRoundBracket = '('.
	closeRoundBracket = ')'.
	openCurlyBracket = '{'.
	closeCurlyBracket = '}'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO cr lf

IGNORE cr + lf + tab

PRODUCTIONS

/*--------------------------------------------------------------------*/
/*----------------------------------identifier----------------------------------*/
identifier<out String value>
= 
id
(. 
    value = t.val;
    System.out.println(t.val);
 .)
.
/*----------------------------------staticAccess----------------------------------*/
staticAccess<out int modifier> 
= 
 "static" (.modifier = Constants.ACC_STATIC;.)
.
/*----------------------------------finalAccess----------------------------------*/
finalAccess<out int modifier>
=
 "final" (.modifier = Constants.ACC_FINAL;.)
.
/*----------------------------------CompilationUnit----------------------------------*/
CompilationUnit = 
	typeDeclaration {typeDeclaration}
	(.checkTypes();.)
.
/*----------------------------------typeDeclaration----------------------------------*/
typeDeclaration =
    (. int specifier = 0;.)
	[accessSpecifier<out specifier>]
	(
		interfaceDeclaration<specifier> 
		|
		classDeclaration<specifier>
	)
.
/*----------------------------------classDeclaration----------------------------------*/
classDeclaration<int modifier> =  
	[finalAccess<out int fMod>     (.modifier |= fMod;.)]    
	[staticAccess<out int sMod>    (.modifier |= sMod;.)]   
	"class"
	identifier<out String className>
	(.String superName = "java.lang.Object";.)
	["extends" identifier<out superName>]
	(.String interfaceName = null;.)
	["implements"
		identifier<out interfaceName> 
		(.
		   ClassGen classGen = new ClassGen(
		       className, 
		       superName, 
		       className+".class", 
		       modifier,
		       interfaceName==null ? null : new String[]{interfaceName} );
		   classes.put(interfaceName, classGen);
		.)
	]
	classBody
.
/*----------------------------------interfaceDeclaration----------------------------------*/
interfaceDeclaration<int modifier> =
	"interface"
	(. modifier |= Constants.ACC_INTERFACE | Constants.ACC_ABSTRACT; .) 
	identifier<out String interfaceName>
	(.String superInterfaceName = null;.)
    ["extends" 
        identifier<out superInterfaceName>
    ]
	(.
	   ClassGen classGen = new ClassGen(
	       interfaceName, 
	       "java.lang.Object", 
	       interfaceName+".class", 
	       modifier,
	       superInterfaceName==null ? null : new String[]{superInterfaceName} );
	   classes.put(interfaceName, classGen);
	.)   
	interfaceBody<classGen>
.
/*----------------------------------accessSpecifier----------------------------------*/
accessSpecifier<out int specifier> =
	(
	"public"       (.specifier = Constants.ACC_PUBLIC;.)
	| 
	"protected"    (.specifier = Constants.ACC_PROTECTED;.)
	| 
	"private"      (.specifier = Constants.ACC_PRIVATE;.)
	)
	(.specifier = 0;.)
.
/*----------------------------------type----------------------------------*/
type<out Type typeLiteral> =
    (.typeLiteral = null;.)
	(
	   "byte"      (.typeLiteral = Type.BYTE;.)
	   | 
	   "short"     (.typeLiteral = Type.SHORT;.)
	   | 
	   "int"       (.typeLiteral = Type.INT;.)
	   | 
	   "char"      (.typeLiteral = Type.CHAR;.)
	   | 
	   "float"     (.typeLiteral = Type.FLOAT;.)
	   | 
	   "boolean"   (.typeLiteral = Type.BOOLEAN;.)
	   | 
	   "void"      (.typeLiteral = Type.VOID;.)
	   |
	   "String"    (.typeLiteral = new ObjectType("java.lang.String");.)
	   |
	   "Vector"    (.typeLiteral = new ObjectType("java.util.Vector");.)
	)
.
/*----------------------------------formalParameterList----------------------------------*/
formalParameterList<Args args> =
    (.ArrayList<Type> types = new ArrayList<Type>();.)  
    (.ArrayList<String> names = new ArrayList<String>();.)
      
    (.Type typeLiteral = null;.)
    (
        type<out typeLiteral>       
        | 
        identifier<out String typeName>  
        (.
         typeLiteral = objectTypes.get(typeName);
         if(typeLiteral==null)
         {   
             typeLiteral = new ObjectType(typeName);
             objectTypes.put(typeName, (ObjectType)typeLiteral);
         }
        .)
    )
    (.types.add(typeLiteral);.)
	identifier<out String param>
	(.names.add(param);.)
	{
        ',' 
	    (
	        type<out typeLiteral>       
	        | 
	        identifier<out String typeName>  
	        (.
	         typeLiteral = objectTypes.get(typeName);
	         if(typeLiteral==null)
	         { 
	             typeLiteral = new ObjectType(typeName);
	             objectTypes.put(typeName, (ObjectType)typeLiteral);
	         }
	        .)
	    )
	   (.types.add(typeLiteral);.) 
	   identifier<out param>
	   (.names.add(param);.)
	}
	(.
	   args.argTypes = types.toArray(new Type[types.size()]);
	   args.argNames = names.toArray(new String[names.size()]);
	.)
.
/*----------------------------------classBody----------------------------------*/
classBody =
	'{'
	{
		[accessSpecifier<out int specifier>]
		((IF(next(_openRoundBracket))
			identifier<out String someThing> //todo
			(.Args args = new Args();.)
			openRoundBracket [formalParameterList<args>] closeRoundBracket 
				openCurlyBracket {statement} closeCurlyBracket
		)
		|
		(
		[finalAccess<out int fMod>]
		[staticAccess<out int sMod>]
		(IF(next(_identifier))
		    (.String typeName = "void";.)
			(
			 type<out Type typeLiteral>
			 | 
			 identifier<out typeName>
			)
			identifier<out String someThing> //todo
			(
				(
				    (.Args args = new Args();.)
					openRoundBracket [formalParameterList<args>] closeRoundBracket 
						openCurlyBracket {statement} closeCurlyBracket
				)
			|
				(
					['=' expression] ';'
				)
			)
		)
		)
		)
	}
	'}'
.
/*----------------------------------statement----------------------------------*/
statement =	
	(
		(
		  "if" openRoundBracket expression closeRoundBracket 
		  (
		      (
		          openCurlyBracket 
		          {
		              statement
		          }
		          closeCurlyBracket
		      )
		      |
		      statement
		  )
	      [
	           "else"
	           (
	               (
	                   openCurlyBracket
	                   {statement}
	                   closeCurlyBracket
	               )
	               |
	               statement
	           )
	      ]
		)
		|
		(
		  "while" openRoundBracket expression closeRoundBracket 
		  (
		      (
		          openCurlyBracket
		          {statement}
		          closeCurlyBracket
		      )
		      |
		      statement
		  )
		)
		|
		("return"[expression]';')
		|
		(
		  "new" expressionName openRoundBracket [expression] closeRoundBracket
		)
		|
		(
		  openCurlyBracket
		  {statement}
		  closeCurlyBracket
		)
		|
		(
		  type<out Type typeLiteral> identifier<out String someThing> //todo
		  ['=' expression]
		  {
		      ',' identifier<out someThing> //todo
			  ['=' expression]
	      }
	      ';'
	    )
		|
		(
            identifier<out String someThing> //todo
		    [
		      '('
		      [
		          expression
		          {
		              ','
		              expression
		          }
		      ]
		      ')'
		    ] 
		    {
		      '.' 
		      identifier<out someThing> //todo
		      ['('[expression 
		      {
		          ',' expression}]')']
		      }
			  (
			     (
			         identifier<out someThing> //todo
			         ['=' expression] 
			         {
			             ','identifier<out someThing> //todo
			             ['=' expression]
			         }
			         ';'
			     )
			     |
			     ';'
			     |
			     (
			         assignmentOperator expression ';'
			     )
			  )
	   )
	   |
	   (
	       "super"
		    {
		      '.'
		      identifier<out String someThing> //todo
		    } 
			openRoundBracket 
			[
			     expression 
			     {
			         ',' expression
			     }
			]
			closeRoundBracket 
			';'
	   )
	)
.

/*----------------------------------interfaceBody----------------------------------*/
interfaceBody<ClassGen classGen> =
	'{'
	{
	   (.int modifier = 0;.)
		[accessSpecifier<out modifier>
		  (.     
		      if (modifier == Constants.ACC_PRIVATE || modifier == Constants.ACC_PROTECTED)
                SemErr("interface memebers ought to be public or default");
              modifier = Constants.ACC_PUBLIC;
          .)
		]
		[finalAccess<out int fMod>    (.modifier |= fMod;.)]
		[staticAccess<out int sMod>   (.modifier |= sMod;.)]
		(.Type typeLiteral = null;.)
		(
			type<out typeLiteral>       
			| 
			identifier<out String typeName>  
			(.
			 typeLiteral = objectTypes.get(typeName);
			 if(typeLiteral==null)
			 {   // todo что-то делать с импортами
			     typeLiteral = new ObjectType(typeName);
			     objectTypes.put(typeName, (ObjectType)typeLiteral);
			 }
			.)
		)
		identifier<out String methodName>	
		(.Args args = new Args();.)
		openRoundBracket [formalParameterList<args>] closeRoundBracket ';'
		(.
		  MethodGen methodGen = new MethodGen(
		      modifier,
              typeLiteral,
              args.argTypes,
              args.argNames,
              methodName,
              classGen.getClassName(),
              null, // instructions list
              classGen.getConstantPool()
		  );
		.)
	}
	'}'
.
/*----------------------------------expression----------------------------------*/
expression =
	conditionalOrExpression 
.
/*----------------------------------conditionalOrExpression----------------------------------*/
conditionalOrExpression =
	conditionalAndExpression {"||" conditionalOrExpression}
.
/*----------------------------------conditionalAndExpression----------------------------------*/
conditionalAndExpression =
	inclusiveOrExpression {"&&" conditionalAndExpression}
.
/*----------------------------------inclusiveOrExpression----------------------------------*/
inclusiveOrExpression =
	exclusiveOrExpression {'|' inclusiveOrExpression}
.
/*----------------------------------exclusiveOrExpression----------------------------------*/
exclusiveOrExpression =
	andExpression {'^' exclusiveOrExpression}
.
/*----------------------------------andExpression----------------------------------*/
andExpression =
	equalityExpression {'&' andExpression}
.
/*----------------------------------equalityExpression----------------------------------*/
equalityExpression =
	relationalExpression {("==" | "!=") equalityExpression}
.
/*----------------------------------relationalExpression----------------------------------*/
relationalExpression =
	shiftExpression {("<" | ">" | "<=" | ">=") relationalExpression}
.
/*----------------------------------shiftExpression----------------------------------*/
shiftExpression =
	additiveExpression {("<<" | ">>" | "<<<" ) shiftExpression}
.
/*----------------------------------additiveExpression----------------------------------*/
additiveExpression =
	multiplicativeExpression {('+' | '-' ) additiveExpression}
.
/*----------------------------------multiplicativeExpression----------------------------------*/
multiplicativeExpression =
	unaryExpression {('*' | '/' | '%' ) multiplicativeExpression}
.
/*----------------------------------unaryExpression----------------------------------*/
unaryExpression =
	expressionName {('*' | '/' | '%' ) unaryExpression}
.
/*----------------------------------expressionName----------------------------------*/
expressionName =
	(((
	identifier<out String someThing> //todo
	 | "super") ['('[expression {',' expression}]')'] 
	   {'.' 
	   identifier<out String someThing> //todo
	   ['('[expression {',' expression}]')']}) | (realNumber)|(string))
.
/*----------------------------------assignmentOperator----------------------------------*/
assignmentOperator =
	("=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=")
.
END CompilationUnit.
