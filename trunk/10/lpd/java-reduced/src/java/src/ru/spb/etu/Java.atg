import org.apache.bcel.Constants;
import org.apache.bcel.generic.ClassGen;
import org.apache.bcel.generic.MethodGen;
import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.ObjectType;
import org.apache.bcel.generic.InstructionList;

import java.util.ArrayList;
import java.util.HashMap;

COMPILER CompilationUnit

// Функция возвращает токен, следующий за текущим (заглядывает вперед)
boolean next(int i)
	{
		scanner.ResetPeek();
		Token peek = scanner.Peek();
		return (peek.kind == i);
	}
	
	void checkTypes()
    {
        for ( String typeName : objectTypes.keySet() )
        {
            if (
                !typeName.equals("String") && 
                !typeName.equals("Vector") &&
                !classes.keySet().contains( typeName ) 
                )
            {
                SemErr( "type " + typeName + " not found" );
            }
        }
    }
    
    public class Args
    {
        Type[] argTypes = null;
        String[] argNames = null;
    }
    
    public void log(String msg)
    {
        System.out.println(msg);        
    }

    public HashMap<String, ClassGen> classes = new HashMap<String, ClassGen>();
    public HashMap<String, ObjectType> objectTypes = new HashMap<String, ObjectType>();
/*--------------------------------------------------------------------------*/
CHARACTERS
  tab           = '\u0009'. /*  9 = tabulator */
  lf            = '\u000a'. /* 10 = line feed */
  cr            = '\u000d'. /* 13 = carriage return */
  
  zero          = '0'.
  zeroToThree   = zero + "123".
  octalDigit    = zero + "1234567". 
  nonZeroDigit  = "123456789".
  digit         = '0' + nonZeroDigit.
  hexDigit      = digit + "ABCDEFabcdef".
  letter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '$'.

  char          = ANY - "'" - '\\' - cr - lf.
  stringChar    = ANY - "\"" - '\\' - cr - lf. 

TOKENS
	id                 = letter { letter | digit }.
	openRoundBracket   = '('.
	closeRoundBracket  = ')'.
	openCurlyBracket   = '{'.
	closeCurlyBracket  = '}'.
	
    /*-------------------------------------------------------------------------*/
    intLit = 
	    ( 
	          zero
	        | nonZeroDigit { digit }
	        | ( "0x" | "0X" ) hexDigit { hexDigit }
	        | '0' octalDigit { octalDigit }
	    ) [ "l" | "L" ].
    /*-------------------------------------------------------------------------*/
    floatLit =
        "." digit {digit} 
        [ ("e" | "E") ["+" | "-"] digit {digit} ] 
        [ "F" | "f" | "D" | "d" ]
        | digit {digit} 
        (
            "." {digit} 
            [("e" | "E" ) ["+" | "-"] digit {digit} ] [ "F" | "f" | "D" | "d" ]
            |
            ("e" | "E") ["+" | "-"] digit {digit} [ "F" | "f" | "D" | "d" ]
            |
            "F" | "f" | "D" | "d"
        ).  
    /*-------------------------------------------------------------------------*/
    charLit = 
        "'"
        (
            char
            |
            "\\"
            (
                "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\" | "u" { "u" }
                hexDigit hexDigit hexDigit hexDigit
                | 
                zeroToThree [ octalDigit ] [ octalDigit ]
                |
                octalDigit [ octalDigit ]
            )
        ) 
        "'".
    /*-------------------------------------------------------------------------*/
    stringLit = 
        "\""
        {
            stringChar
            | "\\" 
            (
                "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\" | "u" { "u" }
                 hexDigit hexDigit hexDigit hexDigit
                |
                zeroToThree [ octalDigit ] [ octalDigit ]
                |
                octalDigit [ octalDigit ]
            )
         } 
        "\"".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO cr lf

IGNORE cr + lf + tab

PRODUCTIONS

/*----------------------------------identifier----------------------------------*/
identifier<out String value>
= 
id
(. 
    value = t.val;
    log("id="+t.val);
 .)
.
/*----------------------------------staticAccess----------------------------------*/
staticAccess<out int modifier> 
= 
 "static" (.modifier = Constants.ACC_STATIC;.)
.
/*----------------------------------finalAccess----------------------------------*/
finalAccess<out int modifier>
=
 "final" (.modifier = Constants.ACC_FINAL;.)
.
/*----------------------------------CompilationUnit----------------------------------*/
CompilationUnit = 
	typeDeclaration {typeDeclaration}
	(.checkTypes();.)
.
/*----------------------------------typeDeclaration----------------------------------*/
typeDeclaration =
    (. int specifier = 0;.)
	[accessSpecifier<out specifier>]
	(
		interfaceDeclaration<specifier> 
		|
		classDeclaration<specifier>
	)
.
/*----------------------------------classDeclaration----------------------------------*/
classDeclaration<int modifier> =  
	[finalAccess<out int fMod>     (.modifier |= fMod;.)]    
	[staticAccess<out int sMod>    (.modifier |= sMod;.)]   
	"class"
	identifier<out String className>
	(.String superName = "java.lang.Object";.)
	["extends" identifier<out superName>]
	(.String interfaceName = null;.)
	["implements"
		identifier<out interfaceName> 
	]
	(.
	   ClassGen classGen = new ClassGen(
	       className, 
	       superName, 
	       className+".class", 
	       modifier,
	       interfaceName==null ? null : new String[]{interfaceName} );
	   classes.put(className, classGen);
	   log("class "+className+" created");
	.)
	classBody<classGen>
.
/*----------------------------------interfaceDeclaration----------------------------------*/
interfaceDeclaration<int modifier> =
	"interface"
	(. modifier |= Constants.ACC_INTERFACE | Constants.ACC_ABSTRACT; .) 
	identifier<out String interfaceName>
	(.String superInterfaceName = null;.)
    ["extends" 
        identifier<out superInterfaceName>
    ]
	(.
	   ClassGen classGen = new ClassGen(
	       interfaceName, 
	       "java.lang.Object", 
	       interfaceName+".class", 
	       modifier,
	       superInterfaceName==null ? null : new String[]{superInterfaceName} );
	   classes.put(interfaceName, classGen);
	   log("interface "+interfaceName+" created");
	.)   
	interfaceBody<classGen>
.
/*----------------------------------accessSpecifier----------------------------------*/
accessSpecifier<out int specifier> =
	(
	"public"       (.specifier = Constants.ACC_PUBLIC;.)
	| 
	"protected"    (.specifier = Constants.ACC_PROTECTED;.)
	| 
	"private"      (.specifier = Constants.ACC_PRIVATE;.)
	)
	(.specifier = 0;.)
.
/*----------------------------------type----------------------------------*/
type<out Type typeLiteral> =
    (.typeLiteral = null;.)
	(
	   "byte"      (.typeLiteral = Type.BYTE;.)
	   | 
	   "short"     (.typeLiteral = Type.SHORT;.)
	   | 
	   "int"       (.typeLiteral = Type.INT;.)
	   | 
	   "char"      (.typeLiteral = Type.CHAR;.)
	   | 
	   "float"     (.typeLiteral = Type.FLOAT;.)
	   | 
	   "boolean"   (.typeLiteral = Type.BOOLEAN;.)
	   | 
	   "void"      (.typeLiteral = Type.VOID;.)
	   |
	   "String"    (.typeLiteral = new ObjectType("java.lang.String");.)
	   |
	   "Vector"    (.typeLiteral = new ObjectType("java.util.Vector");.)
	)
.
/*----------------------------------formalParameterList----------------------------------*/
formalParameterList<Args args> =
    (.ArrayList<Type> types = new ArrayList<Type>();.)  
    (.ArrayList<String> names = new ArrayList<String>();.)
      
    (.Type typeLiteral = null;.)
    (
        type<out typeLiteral>       
        | 
        identifier<out String typeName>  
        (.
         typeLiteral = objectTypes.get(typeName);
         if(typeLiteral==null)
         {   
             typeLiteral = new ObjectType(typeName);
             objectTypes.put(typeName, (ObjectType)typeLiteral);
         }
        .)
    )
    (.types.add(typeLiteral);.)
	identifier<out String param>
	(.names.add(param);.)
	{
        ',' 
	    (
	        type<out typeLiteral>       
	        | 
	        identifier<out String typeName>  
	        (.
				 typeLiteral = objectTypes.get(typeName);
				 if(typeLiteral==null)
				 { 
				     typeLiteral = new ObjectType(typeName);
				     objectTypes.put(typeName, (ObjectType)typeLiteral);
				 }
	        .)
	    )
	   (.types.add(typeLiteral);.) 
	   identifier<out param>
	   (.names.add(param);.)
	}
	(.
	   args.argTypes = types.toArray(new Type[types.size()]);
	   args.argNames = names.toArray(new String[names.size()]);
	.)
.
/*----------------------------------classBody----------------------------------*/
classBody<ClassGen classGen> =
	'{'
	{
	    (.int modifier = 0;.)
		[accessSpecifier<out modifier>]
        [finalAccess<out int fMod>      (.modifier |= fMod;.)]
        [staticAccess<out int sMod>     (.modifier |= sMod;.)]
		(
            (
                IF(next(_openRoundBracket))
                // это конструктор
			        identifier<out String methodName>   
			        (.Args args = new Args();.)
			        openRoundBracket [formalParameterList<args>] closeRoundBracket
			        (.
                          InstructionList il = new InstructionList();
						  MethodGen methodGen = new MethodGen(
						      modifier,
						      new ObjectType(classGen.getClassName()), // todo сохранить
						      args.argTypes,
						      args.argNames,
						      "<init>",
						      classGen.getClassName(),
						      il,
						      classGen.getConstantPool()
						  );
                          log("method "+methodName+" created");						  
			        .) 
			        openCurlyBracket {Statement} closeCurlyBracket
		    )
            |
            (   // это обычный член класса
                (.Type typeLiteral = null;.)
                (
                    type<out typeLiteral>       
                    | 
                    identifier<out String typeName>  
                    (.
                     typeLiteral = objectTypes.get(typeName);
                     if(typeLiteral==null)
                     {
                         typeLiteral = new ObjectType(typeName);
                         objectTypes.put(typeName, (ObjectType)typeLiteral);
                         log("added type "+typeName);
                     }
                    .)
                )
	            identifier<out String someThing>
                (
                    ( // это метод
                        (.Args args = new Args();.)
                        openRoundBracket [formalParameterList<args>] closeRoundBracket 
                        Statement
		            )
                    |
                    ( // это атрибут
                        ['=' Expression ] ';'
                    )
	            )
            )
		)
	}
	'}'
.
/*----------------------------------interfaceBody----------------------------------*/
interfaceBody<ClassGen classGen> =
	'{'
	{
	   (.int modifier = 0;.)
		[accessSpecifier<out modifier>
		  (.     
		      if (modifier == Constants.ACC_PRIVATE || modifier == Constants.ACC_PROTECTED)
                SemErr("interface memebers ought to be public or default");
              modifier = Constants.ACC_PUBLIC;
          .)
		]
		[finalAccess<out int fMod>    (.modifier |= fMod;.)]
		[staticAccess<out int sMod>   (.modifier |= sMod;.)]
		(.Type typeLiteral = null;.)
		(
			type<out typeLiteral>       
			| 
			identifier<out String typeName>  
			(.
			 typeLiteral = objectTypes.get(typeName);
			 if(typeLiteral==null)
			 {   // todo что-то делать с импортами
			     typeLiteral = new ObjectType(typeName);
			     objectTypes.put(typeName, (ObjectType)typeLiteral);
			 }
			.)
		)
		identifier<out String methodName>	
		(.Args args = new Args();.)
		openRoundBracket [formalParameterList<args>] closeRoundBracket ';'
		(.
		  MethodGen methodGen = new MethodGen(
		      modifier,
              typeLiteral,
              args.argTypes,
              args.argNames,
              methodName,
              classGen.getClassName(),
              null, // instructions list
              classGen.getConstantPool()
		  );
		.)
	}
	'}'
.

/*---------------------------------------------------------------------------*
 *---------------------------- Statements -----------------------------------*
 *---------------------------------------------------------------------------*/
// инструкция
Statement                           
=
  Block (.log("block");.)
| "if" ParExpression Statement [ "else" Statement ]
| "while" ParExpression Statement
| "return" [ Expression ] ";"
| "break;"
| "continue;"
| ";"
| Expression ';'  
.
/*---------------------------------------------------------------------------*/
// блок кода
Block
= "{" { BlockStatement } "}"
.
/*---------------------------------------------------------------------------*/
// код состоит из объявлений и инструкций
BlockStatement
=
LocalVariableDeclaration ";"
|
Statement
.
/*---------------------------------------------------------------------------*/
// объявление переменной
LocalVariableDeclaration
= 
[ "final" ] type<out Type typeLiteral> identifier<out String varName> 
["=" Expression] 
.
/*---------------------------------------------------------------------------*
 *---------------------------- Expressions ----------------------------------*
 *---------------------------------------------------------------------------*/
Expression
= 
// левая часть
Expression1
// м.б. много присвоений 
{
    AssignmentOperator Expression1 
}
.
/*---------------------------------------------------------------------------*/
Expression1
= 
(.log("expr");.)
// получение объекта
Expression2
// действия с ним
[ Expression1Rest ]
.
/*---------------------------------------------------------------------------*/
Expression1Rest       
=
// бинарная операция с выражением
Infixop Expression2

// еще бинарные операции с выражением
{
    Infixop Expression2
}
.
/*---------------------------------------------------------------------------*/
Expression2               
=
    // единичный объект
    [Primary]
    // последовательность вызовов к объекту 
    {
        Selector
    }
.
/*---------------------------------------------------------------------------*/
Primary
=
    "(" Expression ")"
|   "this" [Arguments]
|   "super" SuperSuffix
|    Literal
|   "new" Creator
// еще вызовы
|
(
    identifier<out String accessor>
    {
        '.'
        identifier<out accessor>
    }
    [Arguments]
)
.
/*---------------------------------------------------------------------------*/
// аргументы вызовов
Arguments                           
=
// в скобках - пусто, одно или несколько выражений
"(" [ Expression { "," Expression } ] ")"
.
/*---------------------------------------------------------------------------*/
// вызов метода предка
SuperSuffix
=
// конструктор
Arguments
| 
// другой метод
'.' identifier<out String accessor>[Arguments ]  
.
/*---------------------------------------------------------------------------*/
// квалифицированное имя
Qualident
= 
identifier<out String accessor>
{
    '.'
    identifier<out accessor>
}
.
/*---------------------------------------------------------------------------*/
// литерал =)
Literal
= 
  (intLit
| floatLit
| charLit
| stringLit
| "true" | "false"
| "null")
(.log("lit="+t.val);.)
.
/*---------------------------------------------------------------------------*/
// вызов конструктора
Creator
= 
    Qualident Arguments
.
/*---------------------------------------------------------------------------*/
// вызов метода
Selector
= 
"." identifier<out String accessor> [Arguments]
.
/*---------------------------------------------------------------------------*/
// выражение в скобках
ParExpression                         
=
"(" Expression ")"
.
/*---------------------------------------------------------------------------*/
// присвоение
AssignmentOperator
= 
  "="
| "+="
| "-="
| "*="
| "/="
| "&="
| "|="
| "^="
| "%="
.
/*---------------------------------------------------------------------------*/
// бинарная операция
Infixop
= 
  "||"
| "&&"
| "^"
| "=="
| "!="
| "<"
| ">"
| "<="
| ">="
| "+"
| "-"
| "*"
| "/"
| "%"
.
/*---------------------------------------------------------------------------*/
END CompilationUnit.
